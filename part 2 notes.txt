Timer app: instead of sequential code flipping back and forth between our two functionalities (countdown of timer, and animated circle), we can use event-based
	coding. where something may trigger an event and that itself will animate the circle.
	> Solving the 'this' issue. We learned new ways of using 'bind', 'call', or 'apply' to pass in an argument of 'this'. Check screenshot.

	Have 2 options on how to update the time remaining (tick). Either store the time left as an instance variable, or store it in the input element (storing inside DOM)

	SVG Elements are HTML elements. Top left corner is the Origin. X-axis increases from left to right. Y-axis increases from top to bottom. You won't have negative X/Y
		Can show multiple shapes in one SVG area
		Circles have a Fill (inside part), and Stroke (border)
		Border or stroke-dasharray, starts being drawn from the right side then goes clockwise. same as circumference (2 * PI * r)

Application Design Pattern: Plan of attack -> Setup boilerplate code -> Identify challenging aspects of the project we're about to work on -> Get started on the project
	Movie Fight app: Big challenges: Need to somehow fetch data about movies (hard-code? or API?), need auto-complete widget from scratch, styling CSS to make it nice
	APIs usually have two return actions. A Listing (Indexing) result or a Show result
	OMDb API key: e7a59c4a
	With Axios we can pass along an object with parameters for requesting the API
	Debouncing: Waiting for some time to pass after the last event to actually do something.
		A reusable debounce function wraps the initial function and gives it a "shield" to protect from requests that are too fast
	Dropdown menu has 2 implementations: #1: Have HTML for input, DIVs, etc for the dropdown, then create anchor tags in JS to append to the DIVs
		Or #2: Have one big DIV in HTML file with class="autocomplete", then we create ALL the HTML for it in JS and insert it in. Less coupling of code. Better!
		^Method #2 results in reusable code to create widgets
	contains() method can help us see if the target of what the user clicked on is inside or outside the dropdown. If outside then we close the dropdown!
	
	But code has problems with not being re-usable: Autocomplete has knowledge of what a movie object is (so can't re-use code for Recipes for example), global variables
		would make it hard to show a second autocomplete on the screen.
	We split our project into two JS files. One index.js, and one autocomplete.js. index.js will hold non-reusable code for our very specific project: it'll pass a
		config object that will pass in info for all the autocomplete.js which has methods like: fetchData(), renderOption() that knows how to render a movie, 
		onOptionSelect() that is invoked when a user clicks an option of the dropdown menu, root element that autocomplete should be rendered into.
		autocomplete.js must have zero knowledge of movies or recipes or blogs. Must be able to be re-usable depending on what gets passed in.
	To compare the movies, maybe we should store the movie data when we fetch/select it.
		We inject the parsed data into the properties of each HTML article element under the data-value tag (aka dataset named value)

JS with the Canvas API: Maze game
	Matter-js: by default, gravity is enabled in our simulation
	Top left of our canvas element is (0, 0) where (x, y). X-axis goes horizontally to the right, Y-axis goes vertically downwards
	Put a rectangle at all 4 edges of the World to create a border.
	Our maze generations are using a 2D Array
		'grid' array will keep track of which cell has been visited: 'false' means not visited before
		'verticals' array will keep track of walls going up and down, 'horizontals' array will keep track of walls going side to side
			a value of 'true' means there's no wall there, a 'false' means there is a wall
	Iterate over our verticals and horizontals array, and draw a rectangle (wall) at every false value


10:10